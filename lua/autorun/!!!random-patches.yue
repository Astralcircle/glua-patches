string_format = string.format
isfunction = isfunction
isstring = isstring
IsValid = IsValid
SERVER = SERVER
pairs = pairs

hook_Add, hook_Remove, hook_Run = nil, nil, nil
do

    hook = hook
    hook_Add = hook.Add
    hook_Remove = hook.Remove
    hook_Run = hook.Run

NAME = "Random Patches"
VERSION = "5.5.0"
FULL_NAME = string_format( "%s v%s", NAME, VERSION )
COLOR = SERVER and Color( 50, 100, 250 ) or Color( 250, 100, 50 )

LIST = {
    "Improvement for gLua": false
}

Patch = nil
do

    FCVAR_FLAGS = bit.bor( FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_DONTRECORD )
    FCVAR_ARCHIVE = FCVAR_ARCHIVE
    :AddChangeCallback = cvars
    CreateConVar = CreateConVar
    :gsub, :lower = string
    assert = assert

    Patch = ( name, enable, disable, shared ) ->
        assert( isstring( name ), "Argument #1 must be a string!" )
        assert( isfunction( enable ), "Argument #2 must be a function!" )

        unless isfunction( disable )
            LIST[ name ] = false
            return enable!

        conVarName = ( SERVER and "s" or "c" ) .. "patch_" .. gsub( lower( name ), "[%s%p]", "_" )
        LIST[ name ] = conVarName

        if CreateConVar( conVarName, "1", shared and FCVAR_FLAGS or FCVAR_ARCHIVE, name, 0, 1 )\GetBool!
            enable!

        AddChangeCallback( conVarName, ( _, __, value ) ->
            if value == "1"
                enable!
                return

            disable!,
        FULL_NAME .. "::" .. name )

GetHookName = ( patchName, hookName ) ->
    return FULL_NAME .. "::" .. patchName .. ( hookName or "" )

do

    cvars_Bool = cvars.Bool
    MsgC = MsgC

    concommand.Add ( SERVER and "sv_" or "cl_" ) .. "patches", ( ply, __, args ) ->
        if SERVER and IsValid( ply ) and not ply\IsListenServerHost!
            ply\ChatPrint( string_format( "[%s] You do not have enough permissions to run this command.", FULL_NAME ) )
            return

        output = string_format( "%s is a patch/improvement pack for Garry's Mod.\nDeveloped by Pika Software.\nPatch List:\n", FULL_NAME )
        for name, value in pairs( LIST )
            output ..= string_format( " - [%s] %s\n", ( not value or cvars_Bool( value ) ) and "*" or " ", name )

        MsgC( COLOR, output )

MsgC( COLOR, "[" .. FULL_NAME .. "] ", color_white, table.Random( { "Here For You â™ª", "Game Patched!", "OK", "Successfully initialized!", "Hello there", "Specially for you!", "Hello?", "Wow", "Powered by Pika Software!", "Made with <3", "Yeah, well", "Init!", "Im here :" } ) .. "\n" )

string.StartsWith = string.StartsWith or string.StartWith

math.Clamp = ( number, min, max ) ->
	if number < min
        return min

    if number > max
        return max

	return number

do

    table = table
    math_random = math.random
    table_GetKeys = table.GetKeys

    table.Shuffle = ( tbl ) ->
        len = #tbl
        for i = len, 1, -1 do
            rand = math_random( len )
            tbl[ i ], tbl[ rand ] = tbl[ rand ], tbl[ i ]
        return tbl

    table.Random = ( tbl, issequential ) ->
        keys = issequential and tbl or table_GetKeys( tbl )
        rand = keys[ math_random( 1, #keys ) ]
        return tbl[ rand ], rand

iscfunction = ( value ) ->
	unless isfunction( value )
        return false
	return debug.getinfo( value ).short_src == "[C]"

ENTITY = FindMetaTable( "Entity" )
ENTITY_IsValid = ENTITY.IsValid

do

    hookName = GetHookName( "Player Shoot Position Fix" )

    Patch( "Player Shoot Position Fix" , ->
        hook_Add "SetupMove", hookName, =>
            if @IsBot! or not @Alive!
                return

            @m_RealShootPos = @GetShootPos!

        hook_Add "EntityFireBullets", hookName, ( data ) =>
            if not @IsPlayer! or @IsBot! or not @Alive!
                return

            src = @GetShootPos!
            if data.Src == src
                data.Src = @m_RealShootPos or src
                return true
    ->
        hook_Remove "EntityFireBullets", hookName
        hook_Remove "SetupMove", hookName
    true )

do

    hookName = GetHookName( "Blood After Death Fix" )

    Patch( "Blood After Death Fix", ->
        gameevent.Listen( "player_hurt" )
        timer_Simple = timer.Simple
        Player = Player

        hook_Add "player_hurt", hookName, ( data ) ->
            health = data.health
            if health > 0
                return

            ply = Player( data.userid )
            unless ply\IsValid! and ply\Alive!
                return

            timer_Simple 0.25, ->
                if ply\IsValid!
                    ply\RemoveAllDecals!
    ->
        hook_Remove "player_hurt", hookName
    true )

RunConsoleCommand = RunConsoleCommand
GetConVar = GetConVar

if SERVER

	CreateConVar( "room_type", "0" )
	scripted_ents.Register( {
		Base: "base_point"
		Type: "point"
	}, "info_ladder" )

	Patch( "Deploy Speed", ->
		RunConsoleCommand( "sv_defaultdeployspeed", "1" )
    ->
        conVar = GetConVar( "sv_defaultdeployspeed" )
        if conVar
            RunConsoleCommand( "sv_defaultdeployspeed", conVar\GetDefault! )
    )

    HOOK_MONITOR_HIGH = HOOK_MONITOR_HIGH
	PLAYER = FindMetaTable( "Player" )

    do

        hookName = GetHookName( "Steam Auth Protection" )

        Patch( "Steam Auth Protection", ->
            sv_lan = GetConVar( "sv_lan" )
            PLAYER_Kick = PLAYER.Kick

            hook_Add( "PlayerInitialSpawn", hookName, =>
                if sv_lan\GetBool!
                    return

                if @IsBot! or @IsListenServerHost! or @IsFullyAuthenticated!
                    return

                PLAYER_Kick( @, "Your SteamID wasn\'t fully authenticated, try restart your Steam client." )
            HOOK_MONITOR_HIGH )

        ->
            hook_Remove "PlayerInitialSpawn", hookName
        )

	-- Fix for https://github.com/Facepunch/garrysmod-issues/issues/2447
	-- https://github.com/SuperiorServers/dash/blob/master/lua/dash/extensions/player.lua#L44-L57
	do

        hookName = GetHookName( "Player SetPos" )

        Patch( "Player SetPos", ->
            ENTITY_SetPos = ENTITY.SetPos
            positions = {}

            PLAYER.SetPos = ( pos ) =>
                positions[ @ ] = pos

            hook_Add "PlayerDisconnected", hookName, =>
                positions[ @ ] = nil

            hook_Add "FinishMove", hookName, =>
                pos = positions[ @ ]
                unless pos
                    return

                ENTITY_SetPos( @, pos )
                positions[ @ ] = nil
                return true

        )

    ENTITY_GetInternalVariable = ENTITY.GetInternalVariable
    ENTITY_GetClass = ENTITY.GetClass

    do

        hookName = GetHookName( "Smart Area Portals" )

        Patch( "Smart Area Portals", ->
            ents_FindByClass = ents.FindByClass
            doorClasses = {
                func_door_rotating: true
                prop_door_rotating: true
                func_movelinear: true
                func_door: true
            }

            ENTITY_SetSaveValue = ENTITY.SetSaveValue
            ENTITY_GetName = ENTITY.GetName
            ENTITY_Fire = ENTITY.Fire

            enable = ->
                hook_Add( "EntityRemoved", hookName, ( entity ) ->
                    unless doorClasses[ ENTITY_GetClass( entity ) ]
                        return

                    name = ENTITY_GetName( entity )
                    if #name == 0 then
                        return

                    for portal in *ents_FindByClass( "func_areaportal" )
                        if ENTITY_GetInternalVariable( portal, "target" ) ~= name
                            continue
                        ENTITY_SetSaveValue( portal, "target", "" )
                        ENTITY_Fire( portal, "open" )
                )

            disable = ->
                hook_Remove "EntityRemoved", hookName

            hook_Add "PreCleanupMap", hookName, disable
            hook_Add "PostCleanupMap", hookName, enable
            hook_Add "ShutDown", hookName, disable
            enable!
        ->
            hook_Remove "ShutDown", hookName
            hook_Remove "EntityRemoved", hookName
            hook_Remove "PreCleanupMap", hookName
            hook_Remove "PostCleanupMap", hookName
        )

    do

        hookName = GetHookName( "HL2 Chargers Physics" )

        Patch "HL2 Chargers Physics", ->
            SOLID_VPHYSICS = SOLID_VPHYSICS

            hook_Add( "PlayerSpawnedSENT", hookName, ( _, entity ) ->
                className = ENTITY_GetClass( entity )
                if className ~= "item_suitcharger" and className ~= "item_healthcharger"
                    return

                entity\PhysicsInit( SOLID_VPHYSICS )
                entity\PhysWake!

        ->
            hook_Remove "PlayerSpawnedSENT", hookName
        )

	-- Little optimization idea by Billy (used in voicebox)
	-- "for something that really shouldn't be O(n)"
	-- https://i.imgur.com/yPtoNvO.png
	-- https://i.imgur.com/a0lmB9m.png
    do

        hookName = GetHookName( "UserID Cache" )

        Patch( "UserID Cache", ->
            unless iscfunction( PLAYER.UserID )
                return

            CUserID = PLAYER.CUserID
            unless CUserID
                CUserID = PLAYER.UserID
                PLAYER.CUserID = CUserID

            PLAYER.UserID = =>
                return @__UserID or CUserID( @ )

            cacheUserID = =>
                @__UserID = CUserID( @ )

            hook_Add "PlayerInitialSpawn", hookName, cacheUserID, HOOK_MONITOR_HIGH
            hook_Add "PlayerAuthed", hookName, cacheUserID, HOOK_MONITOR_HIGH
        )

	-- Pod network fix by Kefta (code_gs#4197)
	-- Literally garrysmod-issues #2452
    do

        hookName = GetHookName( "Pod Performance" )

        Patch( "Pod Performance", ->
            EFL_NO_THINK_FUNCTION = EFL_NO_THINK_FUNCTION

            hook_Add "OnEntityCreated", hookName, ( vehicle ) ->
                if ENTITY_GetClass( vehicle ) ~= "prop_vehicle_prisoner_pod"
                    return

                vehicle\AddEFlags( EFL_NO_THINK_FUNCTION )

            hook_Add "PlayerLeaveVehicle", hookName, ( _, vehicle ) ->
                if ENTITY_GetClass( vehicle ) ~= "prop_vehicle_prisoner_pod"
                    return

                hook_Add "Think", vehicle, ( entity ) ->
                    hook_Remove "Think", entity

                    if ENTITY_GetInternalVariable( entity, "m_bEnterAnimOn" ) or ENTITY_GetInternalVariable( entity, "m_bExitAnimOn" )
                        return

                    entity\AddEFlags( EFL_NO_THINK_FUNCTION )

            hook_Add "PlayerEnteredVehicle", hookName, ( _, vehicle ) ->
                if ENTITY_GetClass( vehicle ) ~= "prop_vehicle_prisoner_pod"
                    return

                vehicle\RemoveEFlags( EFL_NO_THINK_FUNCTION )

        ->
            hook_Remove "OnEntityCreated", hookName
            hook_Remove "PlayerLeaveVehicle", hookName
            hook_Remove "PlayerEnteredVehicle", hookName
        )

	-- Fixes for prop_vehicle_prisoner_pod, worldspawn (and other not Valid but not NULL entities) damage taking (bullets only)
	-- Explosive damage only works if is located in front of prop_vehicle_prisoner_pod (wtf?)
    do

        hookName = GetHookName( "prop_vehicle_prisoner_pod Explosive Damage" )

        Patch( "prop_vehicle_prisoner_pod Explosive Damage", ->
            ENTITY_TakePhysicsDamage = ENTITY.TakePhysicsDamage

            hook_Add "EntityTakeDamage", hookName, ( entity, damageInfo ) ->
                if ENTITY_GetClass( entity ) ~= "prop_vehicle_prisoner_pod" or entity.AcceptDamageForce
                    return

                ENTITY_TakePhysicsDamage( entity, damageInfo )

        ->
            hook_Remove "EntityTakeDamage", hookName
        )

    return

do
    cam_Start = cam.Start
    view = { type: "2D" }
    cam.Start2D = ->
        cam_Start( view )

do

    func = LocalPlayer

    if iscfunction( func )
        global CLocalPlayer = func
        entity = nil

        global LocalPlayer = ->
            entity = func!

            if entity and ENTITY_IsValid( entity )
                global LocalPlayer = ->
                    return entity

            return entity

do

    system_HasFocus = system.HasFocus

    do

        lastFocusState = nil

        hook_Add "Think", GetHookName( "OnScreenFocusChanged" ), ->
            focus = system_HasFocus!
            if lastFocusState ~= focus
                lastFocusState = focus
                hook_Run "OnScreenFocusChanged", focus

        do

            hookName = GetHookName( "Render Disabler" )

            Patch( "Render Disabler", ->
                hook_Add "RenderScene", hookName, ->
                    if lastFocusState
                        return

                    return true
            ->
                hook_Remove "RenderScene", hookName
            )

    do

        hookName = GetHookName( "Focus Attack Fix" )

        Patch( "Focus Attack Fix", ->
            IN_ATTACK, IN_ATTACK2 = IN_ATTACK, IN_ATTACK2
            lastNoFocusTime = 0
            CurTime = CurTime

            hook_Add "CreateMove", hookName, ( cmd ) ->
                if ( CurTime! - lastNoFocusTime ) < 0.25
                    cmd\RemoveKey( IN_ATTACK )
                    cmd\RemoveKey( IN_ATTACK2 )

                if system_HasFocus!
                    return

                lastNoFocusTime = CurTime!

        ->
            hook_Remove "CreateMove", hookName
        )

do

    hookName = GetHookName( "False Screen Capture Fix" )
    :IsGameUIVisible, :ActivateGameUI, :HideGameUI = gui

    Patch( "False Screen Capture Fix", ->
        lastState = nil

        hook_Add "OnScreenFocusChanged", hookName, ( focusState ) ->
            if focusState
                if lastState ~= nil
                    if lastState
                        HideGameUI!
                    lastState = nil
            elseif lastState == nil
                lastState = not IsGameUIVisible!
                if lastState
                    ActivateGameUI!

            return
    ->
        hook_Remove "OnScreenFocusChanged", hookName
    )
