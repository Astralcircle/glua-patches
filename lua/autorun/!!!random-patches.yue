hook_Add, hook_Remove = hook.Add, hook.Remove
HOOK_MONITOR_HIGH = HOOK_MONITOR_HIGH
color_white = color_white
isfunction = isfunction
:Simple = timer
SERVER = SERVER
pairs = pairs

addonName = "Random Patches v5.10.0"

getHookName = ( patchName, hookName ) ->
    return addonName .. "::" .. patchName .. ( hookName or "" )

Register = nil
do

    FCVAR_ARCHIVE = FCVAR_ARCHIVE
    FCVAR_FLAGS = bit.bor( FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_DONTRECORD )
    CreateConVar = CreateConVar
    :AddChangeCallback = cvars
    :gsub, :lower = string
    hookName = ""

    Register = ( name, enable, disable, shared ) ->
        hookName = getHookName( name )

        unless isfunction( disable )
            return enable( hookName )

        conVarName = ( SERVER and "sv_" or "cl_" ) .. "patch_" .. gsub( lower( name ), "[%s%p]", "_" )

        if CreateConVar( conVarName, "1", shared and FCVAR_FLAGS or FCVAR_ARCHIVE, name, 0, 1 )\GetBool!
            enable( hookName )

        AddChangeCallback( conVarName, ( _, __, value ) ->
            if value == "1"
                enable( hookName )
            else
                disable( hookName )
        addonName .. "::" .. name )

-- GLua improvements
string.StartsWith = string.StartsWith or string.StartWith

table.Empty = ( tbl ) ->
    for key in pairs( tbl )
        tbl[ key ] = nil

math.Clamp = ( number, min, max ) ->
	if number < min
        return min

    if number > max
        return max

	return number

do

    index, length = 1, 0
    :random = math

    table.Shuffle = ( tbl ) ->
        length = #tbl
        for i = length, 1, -1
            index = random( 1, length )
            tbl[ i ], tbl[ index ] = tbl[ index ], tbl[ i ]

        return tbl

    do

        keys = setmetatable( {}, { __mode: "v" } )

        table.Random = ( tbl, issequential ) ->
            if issequential
                length = #tbl
                if length == 0
                    return nil, nil

                if length == 1
                    index = 1
                else
                    index = random( 1, length )

            else

                length = 0
                for key in pairs( tbl )
                    length += 1
                    keys[ length ] = key

                if length == 0
                    return nil, nil

                if length == 1
                    index = keys[ 1 ]
                else
                    index = keys[ random( 1, length ) ]

            return tbl[ index ], index

ENTITY, PLAYER = nil, nil
do

    findMetaTable = CFindMetaTable
    unless findMetaTable
        findMetaTable = FindMetaTable
        global CFindMetaTable = findMetaTable

    registry = _R
    unless registry

        registry = setmetatable( {}, {
            "__index": ( tbl, key ) ->
                value = findMetaTable( key )
                if value == nil
                    return

                tbl[ key ] = value
                return value
        } )

        global _R = registry

    global FindMetaTable = ( name ) ->
        return registry[ name ]

    debug.getregistry = ->
        return registry

    ENTITY, PLAYER = registry.Entity, registry.Player

    getCTable = ENTITY.GetCTable
    unless getCTable
        getCTable = ENTITY.GetTable
        ENTITY.GetCTable = getCTable

    cache = {}

    hook_Add "EntityRemove", getHookName( "Entity.GetTable" ), =>
        Simple 0, ->
            cache[ @ ] = nil

    getTable = =>
        result = cache[ @ ]
        unless result
            result = getCTable( @ ) or {}
            cache[ @ ] = result

        return result

    ENTITY.GetTable = getTable

    ENTITY.__index = ( key ) =>
        value = ENTITY[ key ]
        if value == nil
            value = getTable( @ )[ key ]

        return value

    PLAYER.__index = ( key ) =>
        value = PLAYER[ key ]
        if value == nil
            value = ENTITY[ key ]
            if value == nil
                return getTable( @ )[ key ]

        return value

    do

        :GetOwner = ENTITY
        :Weapon = registry

        Weapon.__index = ( key ) =>
            if key == "Owner"
                return GetOwner( @ )

            value = Weapon[ key ]
            if value == nil
                value = ENTITY[ key ]
                if value == nil
                    return getTable( @ )[ key ]

            return value

    do

        :Vehicle = registry

        Vehicle.__index = ( key ) =>
            value = Vehicle[ key ]
            if value == nil
                value = ENTITY[ key ]
                if value == nil
                    return getTable( @ )[ key ]

            return value

    do

        :NPC = registry

        NPC.__index = ( key ) =>
            value = NPC[ key ]
            if value == nil
                value = ENTITY[ key ]
                if value == nil
                    return getTable( @ )[ key ]

            return value

:IsValid = ENTITY

do

    GetConVar_Internal = GetConVar_Internal
    cache = {}

    global GetConVar = ( name ) ->
        if cache[ name ] == nil
            value = GetConVar_Internal( name )
            if value == nil
                return

            cache[ name ] = value
            return value

        return cache[ name ]

Register( "Player Shoot Position Fix", ( hookName ) ->
    hook_Add "SetupMove", hookName, =>
        if @IsBot! or not @Alive!
            return

        @m_RealShootPos = @GetShootPos!

    hook_Add "EntityFireBullets", hookName, ( data ) =>
        if not @IsPlayer! or @IsBot! or not @Alive!
            return

        src = @GetShootPos!
        if data.Src == src
            data.Src = @m_RealShootPos or src
            return true

( hookName ) ->
    hook_Remove "EntityFireBullets", hookName
    hook_Remove "SetupMove", hookName,
true )

do

    gameevent.Listen( "player_hurt" )
    Player = Player

    hook_Add "player_hurt", getHookName( "Player Decals Fix" ), ( data ) ->
        health = data.health
        if health > 0
            return

        ply = Player( data.userid )
        if IsValid( ply ) and ply\Alive!
            Simple 0.25, ->
                if IsValid( ply )
                    ply\RemoveAllDecals!

-- Trying to start a new lag compensation session while one is already active!
-- Source: https://github.com/Heyter/glua-turbo/blob/main/2_random_patches.lua
do

    cLagCompensation = PLAYER.CLagCompensation
    unless cLagCompensation
        cLagCompensation = PLAYER.LagCompensation
        PLAYER.CLagCompensation = cLagCompensation

    PLAYER.LagCompensation = ( bool ) =>
        if @m_bLagCompensation ~= bool
            @m_bLagCompensation = bool
            cLagCompensation( @, bool )

hook_Add "PlayerFootstep", getHookName( "Player Footstep Fix" ), =>
    if @IsOnGround!
        return

    return true

do

    MOVETYPE_NOCLIP = MOVETYPE_NOCLIP
    IN_DUCK = IN_DUCK

    hook_Add "StartCommand", getHookName( "Air Crouching Fix" ), ( cmd ) =>
        if @GetMoveType! == MOVETYPE_NOCLIP or @IsOnGround! or cmd\KeyDown( IN_DUCK ) or not @Crouching!
            return

        cmd\AddKey( IN_DUCK )

if SERVER

	CreateConVar( "room_type", "0" )

	scripted_ents.Register( {
		Base: "base_point"
		Type: "point"
	}, "info_ladder" )

    do

        :GetPhysicsObject = ENTITY

        ENTITY.PhysWake = =>
            phys = GetPhysicsObject( @ )
            if phys and phys\IsValid!
                phys\Wake!
                return true

            return false

    hook_Add "PlayerSpawn", getHookName( "Player Color Fix" ), =>
        @SetColor( color_white )

	Register( "Default Deploy Speed Fix", ->
		RunConsoleCommand( "sv_defaultdeployspeed", "1" ),
    ->
        conVar = GetConVar( "sv_defaultdeployspeed" )
        if conVar ~= nil
            RunConsoleCommand( "sv_defaultdeployspeed", conVar\GetDefault! )
    )

    Register( "Steam Auth Protection", ( hookName ) ->
        sv_lan = GetConVar( "sv_lan" )
        :Kick = PLAYER

        hook_Add( "PlayerInitialSpawn", hookName, =>
            if sv_lan\GetBool!
                return

            if @IsBot! or @IsListenServerHost! or @IsFullyAuthenticated!
                return

            Kick( @, "Your SteamID wasn\'t fully authenticated, try restart your Steam client." ),
        HOOK_MONITOR_HIGH ),
    ( hookName ) ->
        hook_Remove "PlayerInitialSpawn", hookName
    )

	-- https://github.com/Facepunch/garrysmod-issues/issues/2447
	-- Source: https://github.com/SuperiorServers/dash/blob/master/lua/dash/extensions/player.lua#L44-L57
	do

        hookName = getHookName( "Player SetPos" )
        :SetPos = ENTITY
        players = {}

        PLAYER.SetPos = ( origin ) =>
            players[ @ ] = origin

        hook_Add "PlayerDisconnected", hookName, =>
            players[ @ ] = nil

        hook_Add "FinishMove", hookName, =>
            if players[ @ ] ~= nil
                SetPos( @, players[ @ ] )
                players[ @ ] = nil
                return true

    :GetInternalVariable = ENTITY
    :GetClass = ENTITY

    do

        :GetName, :SetSaveValue, :Fire = ENTITY
        :FindByClass = ents

        hookName, classes = getHookName( "Area Portals Fix" ), {
            func_door_rotating: true
            prop_door_rotating: true
            func_movelinear: true
            func_door: true
        }

        start = ->
            hook_Add "EntityRemoved", hookName, ( entity ) ->
                unless classes[ GetClass( entity ) ]
                    return

                name = GetName( entity )
                if #name == 0 then
                    return

                for portal in *FindByClass( "func_areaportal" )
                    if GetInternalVariable( portal, "target" ) == name
                        SetSaveValue( portal, "target", "" )
                        Fire( portal, "open" )

        stop = ->
            hook_Remove "EntityRemoved", hookName

        hook_Add "PreCleanupMap", hookName, stop
        hook_Add "PostCleanupMap", hookName, start
        hook_Add "ShutDown", hookName, stop
        start!

    do

        SOLID_VPHYSICS = SOLID_VPHYSICS

        hook_Add "PlayerSpawnedSENT", getHookName( "HL2 Chargers Physics" ), ( _, entity ) ->
            className = GetClass( entity )
            if className == "item_suitcharger" or className == "item_healthcharger"
                entity\PhysicsInit( SOLID_VPHYSICS )
                entity\PhysWake!

	-- Little optimization idea by Billy (used in voicebox)
	-- "for something that really shouldn't be O(n)"
	-- https://i.imgur.com/yPtoNvO.png
	-- https://i.imgur.com/a0lmB9m.png
    do

        cUserID = PLAYER.CUserID
        unless cUserID
            cUserID = PLAYER.UserID
            PLAYER.CUserID = cUserID

        PLAYER.UserID = =>
            return @m_bUserID or cUserID( @ )

        do

            hookName, cacheFunc = getHookName( "UserID Cache" ), =>
                @m_bUserID = cUserID( @ )

            hook_Add "PlayerInitialSpawn", hookName, cacheFunc, HOOK_MONITOR_HIGH
            hook_Add "PlayerAuthed", hookName, cacheFunc, HOOK_MONITOR_HIGH

    -- https://github.com/Facepunch/garrysmod-issues/issues/2452
    do

        hookName = getHookName( "Pod Performance Fix" )
        EFL_NO_THINK_FUNCTION = EFL_NO_THINK_FUNCTION

        hook_Add "OnEntityCreated", hookName, ( entity ) ->
            if GetClass( entity ) == "prop_vehicle_prisoner_pod"
                entity\AddEFlags( EFL_NO_THINK_FUNCTION )

        hook_Add "PlayerLeaveVehicle", hookName, ( _, entity ) ->
            if GetClass( entity ) == "prop_vehicle_prisoner_pod"
                hook_Add "Think", entity, ->
                    hook_Remove "Think", entity

                    if GetInternalVariable( entity, "m_bEnterAnimOn" ) or GetInternalVariable( entity, "m_bExitAnimOn" )
                        return

                    entity\AddEFlags( EFL_NO_THINK_FUNCTION )

        hook_Add "PlayerEnteredVehicle", hookName, ( _, entity ) ->
            if GetClass( entity ) == "prop_vehicle_prisoner_pod"
                entity\RemoveEFlags( EFL_NO_THINK_FUNCTION )
                hook_Remove "Think", entity

	-- Fixes for prop_vehicle_prisoner_pod, worldspawn (and other not Valid but not NULL entities) damage taking (bullets only)
	-- Explosive damage only works if is located in front of prop_vehicle_prisoner_pod (wtf?)
    do

        :TakePhysicsDamage = ENTITY

        hook_Add "EntityTakeDamage", getHookName( "prop_vehicle_prisoner_pod Damage Fix" ), ( entity, damageInfo ) ->
            if GetClass( entity ) ~= "prop_vehicle_prisoner_pod" or entity.AcceptDamageForce
                return

            TakePhysicsDamage( entity, damageInfo )

if CLIENT and not MENU_DLL

    do

        gameevent.Listen( "server_cvar" )

        :GetDefault = FindMetaTable( "ConVar" )
        :OnConVarChanged = cvars
        GetConVar = GetConVar

        values, name, old, new = {}, "", "", ""

        hook_Add "server_cvar", "cvars.OnConVarChanged", ( data ) ->
            name, new = data.cvarname, data.cvarvalue

            old = values[ name ]
            if old == nil
                old = GetDefault( GetConVar( name ) )
                values[ name ] = old
            else
                values[ name ] = new

            OnConVarChanged( name, old, new )

	-- Speeding up LocalPlayer
    do

        getLocalPlayer = util.GetLocalPlayer
        unless getLocalPlayer
            getLocalPlayer = LocalPlayer
            util.GetLocalPlayer = getLocalPlayer

        entity = NULL

        global LocalPlayer = ->
            entity = getLocalPlayer!
            if entity and IsValid( entity )
                global LocalPlayer = ->
                    return entity

            return entity

    -- https://github.com/Facepunch/garrysmod/blob/master/garrysmod/lua/includes/extensions/client/render.lua
    do

        :Start = cam

        do

            view = { type: "2D" }

            cam.Start2D = ->
                Start( view )

        do

            view = { type: "3D" }

            cam.Start3D = ( origin, angles, fov, x, y, w, h, znear, zfar ) ->
                view.origin, view.angles, view.fov = origin, angles, fov

                if x ~= nil and y ~= nil and w ~= nil and h ~= nil
                    view.x, view.y = x, y
                    view.w, view.h = w, h
                    view.aspect = w / h
                else
                    view.x, view.y = nil, nil
                    view.w, view.h = nil, nil
                    view.aspect = nil

                if znear ~= nil and zfar ~= nil
                    view.znear, view.zfar = znear, zfar
                else
                    view.znear, view.zfar = nil, nil

                return Start( view )

	-- https://github.com/Facepunch/garrysmod-issues/issues/1091
    do

        camStack = 0

        cStartOrthoView = cam.CStartOrthoView
        unless cStartOrthoView
            cStartOrthoView = cam.StartOrthoView
            cam.CStartOrthoView = cStartOrthoView

        cam.StartOrthoView = ( a, b, c, d ) ->
            camStack += 1
            cStartOrthoView( a, b, c, d )

        cEndOrthoView = cam.CEndOrthoView
        unless cEndOrthoView
            cEndOrthoView = cam.EndOrthoView
            cam.CEndOrthoView = cEndOrthoView

        cam.EndOrthoView = ->
            if camStack == 0
                return

            camStack -= 1

            if camStack < 0
                camStack = 0

            cEndOrthoView!

    do

        :HasFocus = system

        do

            IN_ATTACK, IN_ATTACK2 = IN_ATTACK, IN_ATTACK2
            lastNoFocusTime = 0
            CurTime = CurTime

            hook_Add "CreateMove", getHookName( "Focus Attack Fix" ), ( cmd ) ->
                if ( CurTime! - lastNoFocusTime ) < 0.25
                    cmd\RemoveKey( IN_ATTACK )
                    cmd\RemoveKey( IN_ATTACK2 )

                if HasFocus!
                    return

                lastNoFocusTime = CurTime!

        do

            :IsGameUIVisible, :ActivateGameUI, :HideGameUI = gui

            lastState = nil
            hook_Add "Think", getHookName( "False Screen Capture Fix" ), ->
                if HasFocus!
                    if lastState ~= nil
                        if lastState
                            HideGameUI!

                        lastState = nil

                elseif lastState == nil
                    lastState = not IsGameUIVisible!
                    if lastState
                        ActivateGameUI!

MsgC( SERVER and Color( 50, 100, 250 ) or Color( 250, 100, 50 ), "[" .. addonName .. "] ", color_white, table.Random( {
    "Here For You ♪", "Game Patched!", "OK", "Successfully initialized!",
    "Powered by Pika Software!", "Made with <3", "Yeah, well", "Alright",
    "Hello there", "Specially for you!", "Hello?", "Wow", "I'm here :",
    "Init!", "Say hi!", "Performance Update"
}, true ) .. "\n" )
