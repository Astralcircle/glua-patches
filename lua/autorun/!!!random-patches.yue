hook_Add, hook_Remove = hook.Add, hook.Remove
HOOK_MONITOR_HIGH = HOOK_MONITOR_HIGH
color_white = color_white
isfunction = isfunction
SERVER = SERVER

addonName = "Random Patches v5.8.0"

getHookName = ( patchName, hookName ) ->
    return addonName .. "::" .. patchName .. ( hookName or "" )

Register = nil
do

    FCVAR_ARCHIVE = FCVAR_ARCHIVE
    FCVAR_FLAGS = bit.bor( FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_DONTRECORD )
    CreateConVar = CreateConVar
    :AddChangeCallback = cvars
    :gsub, :lower = string
    hookName = ""

    Register = ( name, enable, disable, shared ) ->
        hookName = getHookName( name )

        unless isfunction( disable )
            return enable( hookName )

        conVarName = ( SERVER and "sv_" or "cl_" ) .. "patch_" .. gsub( lower( name ), "[%s%p]", "_" )

        if CreateConVar( conVarName, "1", shared and FCVAR_FLAGS or FCVAR_ARCHIVE, name, 0, 1 )\GetBool!
            enable( hookName )

        AddChangeCallback( conVarName, ( _, __, value ) ->
            if value == "1"
                enable( hookName )
            else
                disable( hookName )
        addonName .. "::" .. name )

-- GLua improvements
string.StartsWith = string.StartsWith or string.StartWith

math.Clamp = ( number, min, max ) ->
	if number < min
        return min

    if number > max
        return max

	return number

do

    index, length = 1, 0
    :random = math

    table.Shuffle = ( tbl ) ->
        length = #tbl
        for i = length, 1, -1
            index = random( 1, length )
            tbl[ i ], tbl[ index ] = tbl[ index ], tbl[ i ]

        return tbl

    do

        pairs = pairs
        keys = setmetatable( {}, { __mode: "v" } )

        table.Random = ( tbl, issequential ) ->
            if issequential
                length = #tbl
                if length == 0
                    return nil, nil

                if length == 1
                    index = 1
                else
                    index = random( 1, length )

            else

                length = 0
                for key in pairs( tbl )
                    length += 1
                    keys[ length ] = key

                if length == 0
                    return nil, nil

                if length == 1
                    index = keys[ 1 ]
                else
                    index = keys[ random( 1, length ) ]

            return tbl[ index ], index

-- Function that returns true if the value is a C function
iscfunction = nil
do

    :getinfo = debug

    iscfunction = ( value ) ->
        return isfunction( value ) and getinfo( value ).short_src == "[C]"

    debug.iscfunction = iscfunction

Register( "Player Shoot Position Fix", ( hookName ) ->
    hook_Add "SetupMove", hookName, =>
        if @IsBot! or not @Alive!
            return

        @m_RealShootPos = @GetShootPos!

    hook_Add "EntityFireBullets", hookName, ( data ) =>
        if not @IsPlayer! or @IsBot! or not @Alive!
            return

        src = @GetShootPos!
        if data.Src == src
            data.Src = @m_RealShootPos or src
            return true

( hookName ) ->
    hook_Remove "EntityFireBullets", hookName
    hook_Remove "SetupMove", hookName,
true )

do

    gameevent.Listen( "player_hurt" )
    :Simple = timer
    Player = Player

    hook_Add "player_hurt", getHookName( "Player Decals Fix" ), ( data ) ->
        health = data.health
        if health > 0
            return

        ply = Player( data.userid )
        unless ply\IsValid! and ply\Alive!
            return

        Simple 0.25, ->
            unless ply\IsValid!
                return

            ply\RemoveAllDecals!

PLAYER = FindMetaTable( "Player" )

-- Trying to start a new lag compensation session while one is already active!
-- Source: https://github.com/Heyter/glua-turbo/blob/main/2_random_patches.lua
do

    func = PLAYER.LagCompensation
    if iscfunction( func )
        PLAYER.LagCompensation = ( bool ) =>
            if @__lagCompensation ~= bool
                @__lagCompensation = bool
                func( @, bool )

-- https://github.com/Facepunch/garrysmod-issues/issues/3637
do

    func = game.CleanUpMap
    if iscfunction( func )
        defaultFilters, bits, length = { "env_fire", "entityflame", "_firesmoke" }, 0, 0
        istable = istable
        :band = bit

        game.CleanUpMap = ( dontSendToClients, extraFilters ) ->
            if istable( extraFilters )
                length, bits = #extraFilters, 0
                for i = 1, length
                    for j = 1, 3
                        if extraFilters[ i ] == defaultFilters[ j ]
                            bits += 2 ^ j
                            break

                if band( bits, 2 ) == 0
                    length += 1
                    extraFilters[ length ] = defaultFilters[ 1 ]

                if band( bits, 4 ) == 0
                    length += 1
                    extraFilters[ length ] = defaultFilters[ 2 ]

                if band( bits, 8 ) == 0
                    length += 1
                    extraFilters[ length ] = defaultFilters[ 3 ]

            else
                extraFilters = defaultFilters

            return func( dontSendToClients, extraFilters )

hook_Add "PlayerFootstep", getHookName( "Player Footstep Fix" ), =>
    unless @IsOnGround!
        return true

if SERVER

	CreateConVar( "room_type", "0" )

	scripted_ents.Register( {
		Base: "base_point"
		Type: "point"
	}, "info_ladder" )

    hook_Add "PlayerSpawn", getHookName( "Player Color Fix" ), =>
        @SetColor( color_white )

	Register( "Default Deploy Speed Fix", ->
		RunConsoleCommand( "sv_defaultdeployspeed", "1" ),
    ->
        conVar = GetConVar( "sv_defaultdeployspeed" )
        if conVar ~= nil
            RunConsoleCommand( "sv_defaultdeployspeed", conVar\GetDefault! )
    )

	ENTITY = FindMetaTable( "Entity" )

    Register( "Steam Auth Protection", ( hookName ) ->
        sv_lan = GetConVar( "sv_lan" )
        :Kick = PLAYER

        hook_Add( "PlayerInitialSpawn", hookName, =>
            if sv_lan\GetBool!
                return

            if @IsBot! or @IsListenServerHost! or @IsFullyAuthenticated!
                return

            Kick( @, "Your SteamID wasn\'t fully authenticated, try restart your Steam client." ),
        HOOK_MONITOR_HIGH ),
    ( hookName ) ->
        hook_Remove "PlayerInitialSpawn", hookName
    )

	-- https://github.com/Facepunch/garrysmod-issues/issues/2447
	-- Source: https://github.com/SuperiorServers/dash/blob/master/lua/dash/extensions/player.lua#L44-L57
	do

        hookName = getHookName( "Player SetPos" )
        :SetPos = ENTITY
        players = {}

        PLAYER.SetPos = ( origin ) =>
            players[ @ ] = origin

        hook_Add "PlayerDisconnected", hookName, =>
            players[ @ ] = nil

        hook_Add "FinishMove", hookName, =>
            if players[ @ ] ~= nil
                SetPos( @, players[ @ ] )
                players[ @ ] = nil
                return true

    :GetInternalVariable = ENTITY
    :GetClass = ENTITY

    do

        :GetName, :SetSaveValue, :Fire = ENTITY
        :FindByClass = ents

        hookName, classes = getHookName( "Area Portals Fix" ), {
            func_door_rotating: true
            prop_door_rotating: true
            func_movelinear: true
            func_door: true
        }

        start = ->
            hook_Add "EntityRemoved", hookName, ( entity ) ->
                unless classes[ GetClass( entity ) ]
                    return

                name = GetName( entity )
                if #name == 0 then
                    return

                for portal in *FindByClass( "func_areaportal" )
                    if GetInternalVariable( portal, "target" ) == name
                        SetSaveValue( portal, "target", "" )
                        Fire( portal, "open" )

        stop = ->
            hook_Remove "EntityRemoved", hookName

        hook_Add "PreCleanupMap", hookName, stop
        hook_Add "PostCleanupMap", hookName, start
        hook_Add "ShutDown", hookName, stop
        start!

    do

        SOLID_VPHYSICS = SOLID_VPHYSICS

        hook_Add "PlayerSpawnedSENT", getHookName( "HL2 Chargers Physics" ), ( _, entity ) ->
            className = GetClass( entity )
            if className == "item_suitcharger" or className == "item_healthcharger"
                entity\PhysicsInit( SOLID_VPHYSICS )
                entity\PhysWake!

	-- Little optimization idea by Billy (used in voicebox)
	-- "for something that really shouldn't be O(n)"
	-- https://i.imgur.com/yPtoNvO.png
	-- https://i.imgur.com/a0lmB9m.png
    do

        func = PLAYER.UserID
        if iscfunction( func )
            util.GetUserID = func

            PLAYER.UserID = =>
                return @__userid or func( @ )

        do

            hookName, cacheFunc = getHookName( "UserID Cache" ), =>
                @__userid = func( @ )

            hook_Add "PlayerInitialSpawn", hookName, cacheFunc, HOOK_MONITOR_HIGH
            hook_Add "PlayerAuthed", hookName, cacheFunc, HOOK_MONITOR_HIGH

    -- https://github.com/Facepunch/garrysmod-issues/issues/2452
    do

        hookName = getHookName( "Pod Performance Fix" )
        EFL_NO_THINK_FUNCTION = EFL_NO_THINK_FUNCTION

        hook_Add "OnEntityCreated", hookName, ( entity ) ->
            if GetClass( entity ) == "prop_vehicle_prisoner_pod"
                entity\AddEFlags( EFL_NO_THINK_FUNCTION )

        hook_Add "PlayerLeaveVehicle", hookName, ( _, entity ) ->
            if GetClass( entity ) == "prop_vehicle_prisoner_pod"
                hook_Add "Think", entity, ->
                    hook_Remove "Think", entity

                    if GetInternalVariable( entity, "m_bEnterAnimOn" ) or GetInternalVariable( entity, "m_bExitAnimOn" )
                        return

                    entity\AddEFlags( EFL_NO_THINK_FUNCTION )

        hook_Add "PlayerEnteredVehicle", hookName, ( _, entity ) ->
            if GetClass( entity ) == "prop_vehicle_prisoner_pod"
                entity\RemoveEFlags( EFL_NO_THINK_FUNCTION )
                hook_Remove "Think", entity

	-- Fixes for prop_vehicle_prisoner_pod, worldspawn (and other not Valid but not NULL entities) damage taking (bullets only)
	-- Explosive damage only works if is located in front of prop_vehicle_prisoner_pod (wtf?)
    do

        :TakePhysicsDamage = ENTITY

        hook_Add "EntityTakeDamage", getHookName( "prop_vehicle_prisoner_pod Damage Fix" ), ( entity, damageInfo ) ->
            if GetClass( entity ) ~= "prop_vehicle_prisoner_pod" or entity.AcceptDamageForce
                return

            TakePhysicsDamage( entity, damageInfo )

if CLIENT and not MENU_DLL

	-- Speeding up LocalPlayer
    do

        func = LocalPlayer

        if iscfunction( func )
            util.GetLocalPlayer = func
            entity = nil

            global LocalPlayer = ->
                entity = func!

                if entity and entity\IsValid!
                    global LocalPlayer = ->
                        return entity

                return entity

    -- https://github.com/Facepunch/garrysmod/blob/master/garrysmod/lua/includes/extensions/client/render.lua
    do

        :Start = cam

        do

            view = { type: "2D" }

            cam.Start2D = ->
                Start( view )

        do

            view = { type: "3D" }

            cam.Start3D = ( origin, angles, fov, x, y, w, h, znear, zfar ) ->
                view.origin, view.angles = origin, angles

                if fov ~= nil
                    view.fov = fov

                if x ~= nil
                    view.x = x

                if y ~= nil
                    view.y = y

                w = w or view.w
                h = h or view.h

                if w ~= nil and h ~= nil
                    view.aspect = w / h

                view.w, view.h = w, h

                if znear ~= nil
                    view.znear = znear

                if zfar ~= nil
                    view.zfar = zfar

                return Start( view )

	-- https://github.com/Facepunch/garrysmod-issues/issues/1091
    do

        :max = math
		camStack = 0

        :StartOrthoView = cam
        if iscfunction( StartOrthoView )
            cam.StartOrthoView = ( a, b, c, d ) ->
                camStack = camStack + 1
                StartOrthoView( a, b, c, d )

        :EndOrthoView = cam
        if iscfunction( EndOrthoView )
            cam.EndOrthoView = ->
                if camStack == 0
                    return

                camStack = max( 0, camStack - 1 )
                EndOrthoView!

    do

        :HasFocus = system

        do

            IN_ATTACK, IN_ATTACK2 = IN_ATTACK, IN_ATTACK2
            lastNoFocusTime = 0
            CurTime = CurTime

            hook_Add "CreateMove", getHookName( "Focus Attack Fix" ), ( cmd ) ->
                if ( CurTime! - lastNoFocusTime ) < 0.25
                    cmd\RemoveKey( IN_ATTACK )
                    cmd\RemoveKey( IN_ATTACK2 )

                if HasFocus!
                    return

                lastNoFocusTime = CurTime!

        do

            :IsGameUIVisible, :ActivateGameUI, :HideGameUI = gui

            lastState = nil
            hook_Add "Think", getHookName( "False Screen Capture Fix" ), ->
                if HasFocus!
                    if lastState ~= nil
                        if lastState
                            HideGameUI!

                        lastState = nil

                elseif lastState == nil
                    lastState = not IsGameUIVisible!
                    if lastState
                        ActivateGameUI!

MsgC( SERVER and Color( 50, 100, 250 ) or Color( 250, 100, 50 ), "[" .. addonName .. "] ", color_white, table.Random( { "Here For You ♪", "Game Patched!", "OK", "Successfully initialized!", "Hello there", "Specially for you!", "Hello?", "Wow", "Powered by Pika Software!", "Made with <3", "Yeah, well", "Init!", "Im here :" }, true ) .. "\n" )
