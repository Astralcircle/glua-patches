string_format = string.format
isfunction = isfunction
isstring = isstring
SERVER = SERVER
pairs = pairs

NAME = "Random Patches"
VERSION = "5.3.0"
FULL_NAME = string_format( "%s v%s", NAME, VERSION )
SIDE_COLOR = SERVER and Color( 50, 100, 250 ) or Color( 250, 100, 50 )
LIST = {
    "Improvement for gLua": false
}

cvars_AddChangeCallback = cvars.AddChangeCallback
hook_Add = nil
hook_Run = nil
Patch = nil
do

    hook = hook
    hook_Add = hook.Add
    hook_Run = hook.Run
    CreateConVar = CreateConVar
    setmetatable = setmetatable
    hook_Remove = hook.Remove
    setfenv = setfenv
    assert = assert

	FCVAR_FLAGS = bit.bor( FCVAR_ARCHIVE, FCVAR_REPLICATED )
    _GMETA = {
        __newindex: _G
        __index: _G
    }

    class Patch
        new: ( name, enable, disable ) =>
            assert( isstring( name ), "Argument #1 must be a string!" )
            assert( isfunction( enable ), "Argument #2 must be a function!" )

            enviroment = {}

            do

                lib = {}
                enviroment.hook = setmetatable( lib, {
                    __index: hook
                } )

                lib.Add = ( eventName, identifier, ... ) ->
                    if isstring( identifier )
                        identifier = NAME .. "@" .. name .. "::" .. identifier
                    hook_Add( eventName, identifier, ... )

                lib.Remove = ( eventName, identifier ) ->
                    if isstring( identifier )
                        identifier = NAME .. "@" .. name .. "::" .. identifier
                    hook_Remove( eventName, identifier )

            setmetatable( enviroment, _GMETA )
		    setfenv( enable, enviroment )

            unless isfunction( disable )
                LIST[ name ] = false
                return enable!

		    setfenv( disable, enviroment )

            conVarName = ( SERVER and "s" or "c" ) .. "patch_" .. string.gsub( string.lower( name ), "[%s%p]", "_" )
            LIST[ name ] = conVarName

            if CreateConVar( conVarName, "1", FCVAR_FLAGS, name, 0, 1 )\GetBool!
                enable!

            cvars_AddChangeCallback( conVarName, ( _, __, value ) ->
                if value == "1"
                    enable!
                else
                    disable!
            )

do

    cvars_Bool = cvars.Bool
    MsgC = MsgC

    concommand.Add ( SERVER and "sv_" or "cl_" ) .. "patches", ( ply, __, args ) ->
        if SERVER and IsValid( ply ) and not ply\IsListenServerHost!
            ply\ChatPrint( string_format( "[%s] You do not have enough permissions to run this command.", FULL_NAME ) )
            return

        output = string_format( "%s is a patch/improvement pack for Garry's Mod.\nDeveloped by Pika Software.\nPatch List:\n", FULL_NAME )
        for name, value in pairs( LIST )
            output ..= string_format( " - [%s] %s\n", ( not value or cvars_Bool( value ) ) and "*" or " ", name )

        MsgC( SIDE_COLOR, output )

MsgC( SIDE_COLOR, "[" .. FULL_NAME .. "] ", color_white, table.Random( { "Here For You â™ª", "Game Patched!", "OK", "Successfully initialized!", "Hello there", "Specially for you!", "Hello?", "Wow", "Powered by Pika Software!", "Made with <3", "Yeah, well", "Init!", "Im here :" } ) .. "\n" )

string.StartsWith = string.StartsWith or string.StartWith

math.Clamp = ( number, min, max ) ->
	if number < min
        return min

    if number > max
        return max

	return number

do

    table = table
    math_random = math.random
    table_GetKeys = table.GetKeys

    table.Shuffle = ( tbl ) ->
        len = #tbl
        for i = len, 1, -1 do
            rand = math_random( len )
            tbl[ i ], tbl[ rand ] = tbl[ rand ], tbl[ i ]
        return tbl

    table.Random = ( tbl, issequential ) ->
        keys = issequential and tbl or table_GetKeys( tbl )
        rand = keys[ math_random( 1, #keys ) ]
        return tbl[ rand ], rand

iscfunction = ( value ) ->
	unless isfunction( value )
        return false
	return debug.getinfo( value ).short_src == "[C]"

ENTITY = FindMetaTable( "Entity" )
ENTITY_IsValid = ENTITY.IsValid

Patch( "Player Shoot Position Fix" , ->
    hook.Add "SetupMove", "Capture Source", =>
        if @IsBot! or not @Alive!
            return

        @m_RealShootPos = @GetShootPos!

    hook.Add "EntityFireBullets", "Replace Source", ( data ) =>
        if not @IsPlayer! or @IsBot! or not @Alive!
            return

        src = @GetShootPos!
        if data.Src == src
			data.Src = @m_RealShootPos or src
			return true
->
    hook.Remove "EntityFireBullets", "Replace Source"
    hook.Remove "SetupMove", "Capture Source"
)

Patch( "Invisible Sounds Fix", ->
    ENTITY_GetNoDraw = ENTITY.GetNoDraw

	hook.Add "EntityEmitSound", "Catching", ( data ) ->
		entity = data.Entity
        if entity and ENTITY_IsValid( entity ) and ENTITY_GetNoDraw( entity )
            return true

->
    hook.Remove "EntityEmitSound", "Catching"
)

Patch( "Blood After Death Fix", ->
    gameevent.Listen( "player_hurt" )
    timer_Simple = timer.Simple

    hook.Add "player_hurt", "Player Hurt", ( data ) ->
        health = data.health
        if health > 0
            return

        ply = Player( data.userid )
        unless ply\IsValid! and ply\Alive!
            return

        timer_Simple 0.25, ->
            if ply\IsValid!
                ply\RemoveAllDecals!
->
    hook.Remove "player_hurt", "Player Hurt"
)

RunConsoleCommand = RunConsoleCommand
GetConVar = GetConVar

if SERVER
	CreateConVar( "room_type", "0" )
	scripted_ents.Register( {
		Base: "base_point"
		Type: "point"
	}, "info_ladder" )

	Patch( "Deploy Speed", ->
		RunConsoleCommand( "sv_defaultdeployspeed", "1" )
    ->
        conVar = GetConVar( "sv_defaultdeployspeed" )
        if conVar
            RunConsoleCommand( "sv_defaultdeployspeed", conVar\GetDefault! )
    )

    HOOK_MONITOR_HIGH = HOOK_MONITOR_HIGH
	PLAYER = FindMetaTable( "Player" )

	Patch( "Steam Auth Protection", ->
		sv_lan = GetConVar( "sv_lan" )
        PLAYER_Kick = PLAYER.Kick

		hook.Add( "PlayerInitialSpawn", "Player Spawn", =>
			if sv_lan\GetBool!
                return

            if @IsBot! or @IsListenServerHost! or @IsFullyAuthenticated!
                return

			PLAYER_Kick( @, "Your SteamID wasn\'t fully authenticated, try restart your Steam client." )
		HOOK_MONITOR_HIGH )

	->
		hook.Remove "PlayerInitialSpawn", "Player Spawn"
	)

	-- Fix for https://github.com/Facepunch/garrysmod-issues/issues/2447
	-- https://github.com/SuperiorServers/dash/blob/master/lua/dash/extensions/player.lua#L44-L57
	Patch( "Player SetPos", ->
        ENTITY_SetPos = ENTITY.SetPos
		positions = {}

		PLAYER.SetPos = ( pos ) =>
			positions[ @ ] = pos

        hook.Add "PlayerDisconnected", "Disconnect", =>
            positions[ @ ] = nil

		hook.Add "FinishMove", "SetPos", =>
			pos = positions[ @ ]
            unless pos
                return

			ENTITY_SetPos( @, pos )
			positions[ @ ] = nil
			return true

	)

    ENTITY_GetInternalVariable = ENTITY.GetInternalVariable
    ENTITY_GetClass = ENTITY.GetClass

	Patch( "Smart Area Portals", ->
		ents_FindByClass = ents.FindByClass
		doorClasses = {
			func_door_rotating: true
			prop_door_rotating: true
			func_movelinear: true
			func_door: true
		}

        ENTITY_SetSaveValue = ENTITY.SetSaveValue
        ENTITY_GetName = ENTITY.GetName
        ENTITY_Fire = ENTITY.Fire

		enable = ->
			hook.Add( "EntityRemoved", "Entity Catching", ( entity ) ->
				unless doorClasses[ ENTITY_GetClass( entity ) ]
                    return

				name = ENTITY_GetName( entity )
				if #name == 0 then
                    return

				for portal in *ents_FindByClass( "func_areaportal" )
					if ENTITY_GetInternalVariable( portal, "target" ) ~= name
                        continue
					ENTITY_SetSaveValue( portal, "target", "" )
					ENTITY_Fire( portal, "open" )
			)

		disable = ->
			hook.Remove( "EntityRemoved", "Entity Catching" )

		hook.Add( "PreCleanupMap", "Disable", disable )
		hook.Add( "PostCleanupMap", "Enable", enable )
		hook.Add( "ShutDown", "Disable", disable )
		enable!
    ->
		hook.Remove "EntityRemoved", "Entity Catching"
		hook.Remove "PreCleanupMap", "Disable"
		hook.Remove "PostCleanupMap", "Enable"
	)

	Patch "HL2 Chargers Physics", ->
		SOLID_VPHYSICS = SOLID_VPHYSICS

		hook.Add( "PlayerSpawnedSENT", "Creation", ( _, entity ) ->
            className = ENTITY_GetClass( entity )
            if className ~= "item_suitcharger" and className ~= "item_healthcharger"
                return

            entity\PhysicsInit( SOLID_VPHYSICS )
            entity\PhysWake!

	->
		hook.Remove "PlayerSpawnedSENT", "Creation"
	)

	-- Little optimization idea by Billy (used in voicebox)
	-- "for something that really shouldn't be O(n)"
	-- https://i.imgur.com/yPtoNvO.png
	-- https://i.imgur.com/a0lmB9m.png
	Patch( "UserID Cache", ->
        unless iscfunction( PLAYER.UserID )
            return

		CUserID = PLAYER.CUserID
		unless CUserID
			CUserID = PLAYER.UserID
            PLAYER.CUserID = CUserID

		PLAYER.UserID = =>
			return @__UserID or CUserID( @ )

		cacheUserID = =>
			@__UserID = CUserID( @ )

		hook.Add "PlayerInitialSpawn", "Cache", cacheUserID, HOOK_MONITOR_HIGH
		hook.Add "PlayerAuthed", "Cache", cacheUserID, HOOK_MONITOR_HIGH
	)

	-- Pod network fix by Kefta (code_gs#4197)
	-- Literally garrysmod-issues #2452
	Patch( "Pod Performance", ->
		EFL_NO_THINK_FUNCTION = EFL_NO_THINK_FUNCTION

		hook.Add "OnEntityCreated", "Created", ( vehicle ) ->
			if ENTITY_GetClass( vehicle ) ~= "prop_vehicle_prisoner_pod"
                return

            vehicle\AddEFlags( EFL_NO_THINK_FUNCTION )

		hook.Add "PlayerLeaveVehicle", "Leave", ( _, vehicle ) ->
			if ENTITY_GetClass( vehicle ) ~= "prop_vehicle_prisoner_pod"
                return

            hook.Add "Think", vehicle, ( entity ) ->
				hook.Remove "Think", entity

				if ENTITY_GetInternalVariable( entity, "m_bEnterAnimOn" ) or ENTITY_GetInternalVariable( entity, "m_bExitAnimOn" )
                    return

                entity\AddEFlags( EFL_NO_THINK_FUNCTION )

        hook.Add "PlayerEnteredVehicle", "Enter", ( _, vehicle ) ->
            if ENTITY_GetClass( vehicle ) ~= "prop_vehicle_prisoner_pod"
                return

            vehicle\RemoveEFlags( EFL_NO_THINK_FUNCTION )

	->
		hook.Remove "OnEntityCreated", "Created"
		hook.Remove "PlayerLeaveVehicle", "Leave"
		hook.Remove "PlayerEnteredVehicle", "Enter"
	)

	-- Fixes for prop_vehicle_prisoner_pod, worldspawn (and other not Valid but not NULL entities) damage taking (bullets only)
	-- Explosive damage only works if is located in front of prop_vehicle_prisoner_pod (wtf?)
	Patch( "prop_vehicle_prisoner_pod Explosive Damage", ->
		ENTITY_TakePhysicsDamage = ENTITY.TakePhysicsDamage

        hook.Add "EntityTakeDamage", "Damage Catching", ( entity, damageInfo ) ->
            if ENTITY_GetClass( entity ) ~= "prop_vehicle_prisoner_pod" or entity.AcceptDamageForce
                return

			ENTITY_TakePhysicsDamage( entity, damageInfo )

	->
		hook.Remove "EntityTakeDamage", "Damage Catching"
	)

    return

do
    cam_Start = cam.Start
    view = { type: "2D" }
    cam.Start2D = ->
        cam_Start( view )

do

    func = LocalPlayer

    if iscfunction( func )
        global CLocalPlayer = func
        entity = nil

        global LocalPlayer = ->
            entity = func!

            if entity and ENTITY_IsValid( entity )
                global LocalPlayer = ->
                    return entity

            return entity

do

    system_HasFocus = system.HasFocus

    do

        lastFocusState = system_HasFocus!

        hook_Add "Think", "OnScreenFocusChanged", ->
            currentFocusState = system_HasFocus!
            if lastFocusState ~= currentFocusState
                lastFocusState = currentFocusState
                hook_Run "OnScreenFocusChanged", currentFocusState

    Patch( "Focus Attack Fix", ->
        IN_ATTACK, IN_ATTACK2 = IN_ATTACK, IN_ATTACK2
        lastNoFocusTime = 0
        CurTime = CurTime

        hook.Add "CreateMove", "Attack Limitter", ( cmd ) ->
            if ( CurTime! - lastNoFocusTime ) < 0.25
                cmd\RemoveKey( IN_ATTACK )
                cmd\RemoveKey( IN_ATTACK2 )

            if system_HasFocus!
                return

            lastNoFocusTime = CurTime!

    ->
        hook.Remove "CreateMove", "Attack Limitter"
    )

    Patch( "Render Disabler", ->
        hook.Add "OnScreenFocusChanged", "Render Capture", ( focusState ) ->
            if focusState
                hook.Remove "RenderScene", "Render Disabling"
            else
                hook.Add "RenderScene", "Render Disabling", ->
                    return true
    ->
        hook.Remove "OnScreenFocusChanged", "Render Capture"
        hook.Remove "RenderScene", "Render Disabling"
    )

    Patch( "False Screen Capture Fix", ->
        lastState = nil

        hook.Add "OnScreenFocusChanged", "Catching", ( focusState ) ->
            if focusState
                if lastState ~= nil
                    if lastState
                        gui.HideGameUI!
                    lastState = nil
            elseif lastState == nil
                lastState = not gui.IsGameUIVisible!
                if lastState
                    gui.ActivateGameUI!

    ->
        hook.Remove "OnScreenFocusChanged", "Catching"
    )

string_sub = string.sub

Patch( "Binds Fix", ->
    string_StartsWith = string.StartsWith
    binds = {}

    hook.Add "PlayerBindPress", "Press", ( _, bind, __, keyCode ) ->
        unless string_StartsWith( bind, "+" )
            return

        binds[ keyCode ] = string_sub( bind, 2, #bind )

    hook.Add "PlayerButtonUp", "Release", ( ply, keyCode ) ->
        bind = binds[ keyCode ]
        unless bind
            return

        binds[ keyCode ] = nil
        hook_Run( "PlayerBindPress", ply, "-" .. bind, true, keyCode )

    hook.Add "OnScreenFocusChanged", "Release", ->
        for keyCode, bind in pairs( binds )
            binds[ keyCode ] = nil
            hook_Run( "PlayerBindPress", ply, "-" .. bind, true, keyCode )

)

Patch( "Arrow Camera Control Fix", ->
    state = 0

    hook.Add "PlayerBindPress", "Binds Capture", ( _, bind, isDown ) ->
        unless isDown
            return

        keyPrase = string_sub( bind, 2, #bind )
        if keyPrase == "lookup"
            state = string_sub( bind, 1, 1 ) == "+" and 1 or 0
            return true
        elseif keyPrase == "lookdown"
            state = string_sub( bind, 1, 1 ) == "+" and -1 or 0
            return true

    cl_pitchspeed = GetConVar( "cl_pitchspeed" )
    FrameTime = FrameTime
    IN_SPEED = IN_SPEED

    hook.Add "StartCommand", "Player Controll", ( _, cmd ) ->
        if state == 0
            return
        angles = cmd\GetViewAngles!
        angles[ 1 ] = angles[ 1 ] - ( cl_pitchspeed\GetFloat! * ( FrameTime! * state  ) / ( cmd\KeyDown( IN_SPEED ) and 4 or 2 ) )
        cmd\SetViewAngles( angles )

->
    hook.Remove "StartCommand", "Player Controll"
    hook.Remove "PlayerBindPress", "Binds Capture"
)